<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>STM32学习——PWM舵机控制</title>
    <url>/2020/12/02/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94PWM%E8%88%B5%E6%9C%BA%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h4 id="STM32控制舵机"><a href="#STM32控制舵机" class="headerlink" title="STM32控制舵机"></a>STM32控制舵机</h4><a id="more"></a>
<p>在STM32中控制舵机，实际上就是开发STM32上的PWM功能，这部分功能需要配置STM32的定时器和GPIO复用共功能，然后就是通过修改定时器计数器的比较寄存器的数值来达到控制PWM的高电平占空比的目的。</p>
<hr>
<p>(1) 定时器 IO 配置<br>(2) 定时器时基结构体 TIM_TimeBaseInitTypeDef 配置<br>(3) 定时器输出比较结构体 TIM_OCInitTypeDef 配置<br>(4) 定时器断路和死区结构体 TIM_BDTRInitTypeDef 配置</p>
<hr>
<h6 id="PWM-输出配置步骤（通过TIM1-CH1输出PWM来控舵机）"><a href="#PWM-输出配置步骤（通过TIM1-CH1输出PWM来控舵机）" class="headerlink" title="PWM 输出配置步骤（通过TIM1_CH1输出PWM来控舵机）"></a>PWM 输出配置步骤（通过TIM1_CH1输出PWM来控舵机）</h6><p><strong>1） 开启 TIM1 时钟，配置 PA8 为复用输出。</strong><br>要使用 TIM1，我们必须先开启 TIM1 的时钟，这里我们还要配置 PA8 为复用输出（当然还要时能 PORTA 的时钟），这是因为 TIM1_CH1 通道将使用 PA8 的复用功能作为输出。<br>库函数使能 TIM3 时钟的方法是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //使能定时器 3 时钟</span><br></pre></td></tr></table></figure>
<p>然后设置 PA8 为复用功能输出的。</p>
<p><strong>2）设置 TIM1 的 ARR 和 PSC。</strong><br>配置TIM_TimeBaseInitTypeDef结构体</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TIM_TimeBaseStructure.TIM_Period = arr; //设置自动重装载值</span><br><span class="line">TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置预分频值</span><br></pre></td></tr></table></figure>

<p><strong>3） 设置 TIM1_CH1 的 PWM 模式及通道方向, 使能 TIM1 的 CH1 输出。</strong><br>配置 TIM_OCInitTypeDef 结构体</p>
<p><strong>4） 使能 TIM1</strong><br>使能 TIM1 的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TIM_Cmd(TIM1, ENABLE); //使能 TIM1</span><br></pre></td></tr></table></figure>

<p><strong>5） 设置 MOE 输出，使能 PWM 输出。（高级定时器才需要）</strong><br>普通定时器在完成以上设置了之后，就可以输出PWM了，但是高级定时器，我们还需要使能刹车和死区寄存器（ TIM1_BDTR）的 MOE 位，以使能整个 OCx（即 PWM）输出。<br>库数的设置函数为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">TIM_CtrlPWMOutputs(TIM1,ENABLE);// MOE 主输出使能</span><br></pre></td></tr></table></figure>

<p><strong>6） 修改 TIM1_CCR1 来控制占空比</strong><br>最后，在经过以上设置之后， PWM 其实已经开始输出了，只是其占空比和频率都是固定的，而我们通过修改 TIM1_CCR1 则可以控制 CH1 的输出占空比。<br>在库函数中，修改 TIM1_CCR1 占空比的函数是：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void TIM_SetCompare1(TIM_TypeDef* TIMx, uint16_t Compare1)；</span><br></pre></td></tr></table></figure>
<p>理所当然，对于其他通道，分别有一个函数名字，函数格式为 TIM_SetComparex(x=1,2,3,4)。</p>
<hr>
<h6 id="关于PWM"><a href="#关于PWM" class="headerlink" title="关于PWM"></a>关于PWM</h6><p><img src="https://s3.ax1x.com/2021/01/27/svcgVH.png" alt="TIM5"><br><img src="https://s3.ax1x.com/2021/01/27/svc6qe.png" alt="TIM4"><br><img src="https://s3.ax1x.com/2021/01/27/svcyrD.png" alt="TIM3"><br><img src="https://s3.ax1x.com/2021/01/27/svcDxK.png" alt="TIM2"><br><img src="https://s3.ax1x.com/2021/01/27/svc08x.png" alt="TIM1"></p>
<hr>
<h6 id="关于PB4引脚配置"><a href="#关于PB4引脚配置" class="headerlink" title="关于PB4引脚配置"></a>关于PB4引脚配置</h6><p>很多人遇到这种问题，但是应该注意的是PB4在单片机复位后，它是作为JTAG引脚来使用的，也就是说，要使用PB4你需要自己将其配置成普通GPIO.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE); </span><br></pre></td></tr></table></figure>
<p>配置成普通GPIO后，需要进行部分重映射.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3  , ENABLE);</span><br></pre></td></tr></table></figure>
<p>两步都完成后即可得到正常的PWM波输出</p>
<hr>
<h6 id="代码部分"><a href="#代码部分" class="headerlink" title="代码部分"></a>代码部分</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#include &quot;timer.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;led.h&quot;</span></span><br><span class="line"><span class="comment">#include &quot;usart.h&quot;</span></span><br><span class="line">							  </span><br><span class="line">//通用定时器3中断初始化</span><br><span class="line">//这里时钟选择为APB1的2倍，而APB1为36M</span><br><span class="line">//arr：自动重装值。</span><br><span class="line">//psc：时钟预分频数</span><br><span class="line">//这里使用的是定时器3!</span><br><span class="line">void TIM3_Int_Init(u16 arr,u16 psc)</span><br><span class="line">&#123;</span><br><span class="line">  TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line"></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE); //时钟使能</span><br><span class="line"></span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值	 计数到5000为500ms</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值  10Khz的计数频率  </span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim</span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span><br><span class="line"> </span><br><span class="line">	TIM_ITConfig(TIM3,TIM_IT_Update,ENABLE ); //使能指定的TIM3中断,允许更新中断</span><br><span class="line"></span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;  //TIM3中断</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;  //先占优先级0级</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 3;  //从优先级3级</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE; //IRQ通道被使能</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);  //根据NVIC_InitStruct中指定的参数初始化外设NVIC寄存器</span><br><span class="line"></span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);  //使能TIMx外设</span><br><span class="line">							 </span><br><span class="line">&#125;</span><br><span class="line">//定时器3中断服务程序</span><br><span class="line">void TIM3_IRQHandler(void)   //TIM3中断</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET) //检查指定的TIM中断发生与否:TIM 中断源 </span><br><span class="line">		&#123;</span><br><span class="line">		TIM_ClearITPendingBit(TIM3, TIM_IT_Update  );  //清除TIMx的中断待处理位:TIM 中断源 </span><br><span class="line">		LED1=!LED1;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//TIM3 PWM部分初始化 </span><br><span class="line">//PWM输出初始化</span><br><span class="line">//arr：自动重装值</span><br><span class="line">//psc：时钟预分频数</span><br><span class="line">void TIM3_PWM_Init(u16 arr,u16 psc)</span><br><span class="line">&#123;  </span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;</span><br><span class="line">	TIM_OCInitTypeDef  TIM_OCInitStructure;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);	//使能定时器3时钟</span><br><span class="line"> 	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB  | RCC_APB2Periph_AFIO, ENABLE);  //使能GPIO外设和AFIO复用功能模块时钟</span><br><span class="line">	GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span><br><span class="line">	GPIO_PinRemapConfig(GPIO_PartialRemap_TIM3, ENABLE); //Timer3部分重映射  TIM3_CH2-&gt;PB5    </span><br><span class="line"> </span><br><span class="line">   //设置该引脚为复用输出功能,输出TIM3 CH2的PWM脉冲波形	GPIOB.5</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4|GPIO_Pin_5; //TIM_CH2</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;  //复用推挽输出</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);//初始化GPIO</span><br><span class="line">	</span><br><span class="line"> </span><br><span class="line">   //初始化TIM3</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Period = arr; //设置在下一个更新事件装入活动的自动重装载寄存器周期的值</span><br><span class="line">	TIM_TimeBaseStructure.TIM_Prescaler =psc; //设置用来作为TIMx时钟频率除数的预分频值 </span><br><span class="line">	TIM_TimeBaseStructure.TIM_ClockDivision = 0; //设置时钟分割:TDTS = Tck_tim</span><br><span class="line">	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  //TIM向上计数模式</span><br><span class="line">	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseStructure); //根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	//初始化TIM3 Channel1 PWM模式	 </span><br><span class="line">	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2; //选择定时器模式:TIM脉冲宽度调制模式1</span><br><span class="line"> 	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; //比较输出使能</span><br><span class="line">	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High; //输出极性:TIM输出比较极性高</span><br><span class="line"></span><br><span class="line">	TIM_OC1Init(TIM3, &amp;TIM_OCInitStructure);  //根据T指定的参数初始化外设TIM3 OC1</span><br><span class="line">	TIM_OC1PreloadConfig(TIM3, TIM_OCPreload_Enable);  //使能TIM3在CCR1上的预装载寄存器</span><br><span class="line"> </span><br><span class="line">	TIM_OC2Init(TIM3, &amp;TIM_OCInitStructure);  //根据T指定的参数初始化外设TIM3 OC2</span><br><span class="line">	TIM_OC2PreloadConfig(TIM3, TIM_OCPreload_Enable);  //使能TIM3在CCR2上的预装载寄存器</span><br><span class="line"> </span><br><span class="line">	TIM_Cmd(TIM3, ENABLE);  //使能TIM3</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>学习</tag>
        <tag>元器件</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习笔记——贪吃蛇</title>
    <url>/2020/09/18/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E8%B4%AA%E5%90%83%E8%9B%87/</url>
    <content><![CDATA[<h2 id="初学STM32。"><a href="#初学STM32。" class="headerlink" title="初学STM32。"></a>初学STM32。</h2><hr>
<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><blockquote>
<p>个人学单片机也有一段时间了，跟着教程学习，似乎掌握的不太熟练。偶然见到精品店里出售的迷你游戏机，决定尝试做一个贪吃蛇的小外设。制作过程收获颇多，在此做一个记录与分享。</p>
</blockquote>
<a id="more"></a>
<hr>
<h4 id="使用硬件"><a href="#使用硬件" class="headerlink" title="使用硬件"></a>使用硬件</h4><p>普通摇杆、0.96寸OLED屏幕（SPI协议通讯）、STM32F103RCT6开发板。<br><img src="https://s1.ax1x.com/2020/09/19/wI6IBj.jpg" alt="硬件"></p>
<hr>
<h4 id="接线"><a href="#接线" class="headerlink" title="接线"></a>接线</h4><table>
<thead>
<tr>
<th>OLED</th>
<th></th>
<th></th>
<th>摇杆</th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>GND</td>
<td>GND</td>
<td></td>
<td>GND</td>
<td>GND</td>
</tr>
<tr>
<td>VCC</td>
<td>3.3V</td>
<td></td>
<td>VCC</td>
<td>3.3V</td>
</tr>
<tr>
<td>D0</td>
<td>PC0</td>
<td></td>
<td>VRX</td>
<td>PA0</td>
</tr>
<tr>
<td>D1</td>
<td>PC1</td>
<td></td>
<td>VRY</td>
<td>PA1</td>
</tr>
<tr>
<td>RES</td>
<td>PB15</td>
<td></td>
<td>SW</td>
<td>PA2</td>
</tr>
<tr>
<td>DC</td>
<td>PA3</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>CS</td>
<td>PA6</td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><img src="https://s1.ax1x.com/2020/09/19/wIf3nO.jpg" alt="接线"></p>
<hr>
<h4 id="游戏设计："><a href="#游戏设计：" class="headerlink" title="游戏设计："></a>游戏设计：</h4><p>主要分为前进、控制方向、生成苹果、吃苹果、蛇伸长、撞墙和撞蛇、计分、调速这几个功能。<br>摇杆上的杆用作控制方向，按键则用作调速。<br><img src="https://s1.ax1x.com/2020/09/19/wIW0w4.jpg" alt="游戏中"></p>
<hr>
<h4 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h4><h5 id="一、初始化画面。"><a href="#一、初始化画面。" class="headerlink" title="一、初始化画面。"></a>一、初始化画面。</h5><p>将OLED显示屏分为信息栏部分和游戏显示部分。信息显示部分主要是显示分数和速度。游戏显示部分画出游戏区域框和蛇一开始的位置。<br>在我的设计里是用二维数组储存蛇的位置信息，我将蛇最大长度设为500（蛇长可以根据实际做修改），建立数组 snake[500][2]（snake[i][0]表示蛇x轴位置，snake[i][1]表示蛇y轴的位置）。snake[0]作为蛇尾，往后储存数据直到蛇头。建立蛇的备份数组用来储存初始化蛇的数据，便于用来初始化（<del>后来想想其实可以不用的</del>）。除了用数组储存蛇的数据以外，我在网上还见到用链表储存蛇的数据。（<del>初学C++，课堂上老师没教，不太会用，有空研究研究。</del>）</p>
<h5 id="二、蛇向前运动部分。"><a href="#二、蛇向前运动部分。" class="headerlink" title="二、蛇向前运动部分。"></a>二、蛇向前运动部分。</h5><p><strong>第一步</strong> 灭掉蛇尾（S[1]）的点<br><strong>第二步</strong> 更新蛇位置的数据，使得蛇前进<br><strong>第三步</strong> 点亮蛇头的点<br>只要不断更新，蛇就看起来在前进了。<br>下面是原理图<br><img src="https://s1.ax1x.com/2020/09/19/w5rcIf.jpg" alt="蛇前进原理图"></p>
<h6 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Snake_move( void )</span><br><span class="line">&#123;</span><br><span class="line">	int i; </span><br><span class="line"></span><br><span class="line">	//灭掉蛇尾的点</span><br><span class="line">	Snake_drawpoint( snake[0][0], snake[0][1], 0 );</span><br><span class="line"></span><br><span class="line">	//前进</span><br><span class="line">	<span class="keyword">for</span> ( i = 0; i &lt; snake_long - 1 ; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		snake[i][0] = snake[i+1][0];</span><br><span class="line">		snake[i][1] = snake[i+1][1];</span><br><span class="line">	&#125;</span><br><span class="line">	snake[snake_long - 1][0] = snake[snake_long-1][0]+aim_x;</span><br><span class="line">	snake[snake_long - 1][1] = snake[snake_long-1][1]+aim_y;</span><br><span class="line"></span><br><span class="line">	//点亮蛇头的点</span><br><span class="line">	Snake_drawpoint ( snake[snake_long-1][0],snake[snake_long-1][1],1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="三、控制方向"><a href="#三、控制方向" class="headerlink" title="三、控制方向"></a>三、控制方向</h5><p>使用STM32的ADC功能获取摇杆x轴和y轴的数据，取合适的数据范围并作比较，更新前进方向。注意判断判断得到的前进方向与原方向相反时，不作方向的更新。</p>
<h6 id="代码：-1"><a href="#代码：-1" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Snake_control(void)</span><br><span class="line">&#123;</span><br><span class="line">	u16 x, y;</span><br><span class="line">	u16 x_jud, y_jud;</span><br><span class="line">	u16 tempx;</span><br><span class="line">	u16 tempy;</span><br><span class="line">	</span><br><span class="line">	//读取数据</span><br><span class="line">	tempx = Get_Adc_Average( ADC_Channel_0, 10);</span><br><span class="line">	tempy = Get_Adc_Average( ADC_Channel_1, 10);</span><br><span class="line">	x = tempx &gt;= 2048? (tempx - 2048) : (2048 - tempx);</span><br><span class="line">	y = tempy &gt;= 2048? (tempy - 2048) : (2048 - tempy);</span><br><span class="line">	x_jud = tempx &gt;= 2048? 1 : 0;</span><br><span class="line">	y_jud = tempy &gt;= 2048? 1 : 0;</span><br><span class="line">	</span><br><span class="line">	//确定方向</span><br><span class="line">	<span class="keyword">if</span>( x &gt; 1024 || y &gt; 1024 ) </span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>( x &gt; y &amp;&amp; x_jud == 0 &amp;&amp; aim_x != 1) 	//向左</span><br><span class="line">		&#123;</span><br><span class="line">			aim_x = -1;</span><br><span class="line">			aim_y = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( x &gt; y &amp;&amp; x_jud == 1 &amp;&amp; aim_x != -1)	//向右</span><br><span class="line">		&#123;</span><br><span class="line">			aim_x = 1;</span><br><span class="line">			aim_y = 0;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( y &gt; x &amp;&amp; y_jud == 0 &amp;&amp; aim_y != 1)	//向下</span><br><span class="line">		&#123;</span><br><span class="line">			aim_x = 0;</span><br><span class="line">			aim_y = -1;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>( y &gt; x &amp;&amp; y_jud == 1 &amp;&amp; aim_y != -1)	//向上</span><br><span class="line">		&#123;</span><br><span class="line">			aim_x = 0;</span><br><span class="line">			aim_y = 1;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="四、生成苹果"><a href="#四、生成苹果" class="headerlink" title="四、生成苹果"></a>四、生成苹果</h5><p>利用单片机里的定时器中断服务程序生成随机数种子，然后使用 rand() 生成随机数作为苹果位置的数据。</p>
<h6 id="定时器中断服务函数"><a href="#定时器中断服务函数" class="headerlink" title="定时器中断服务函数"></a>定时器中断服务函数</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u32 seed = 0;</span><br><span class="line">void TIM3_IRQHandler( void )   //TIM3中断</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (TIM_GetITStatus(TIM3, TIM_IT_Update) != RESET)</span><br><span class="line">		&#123;</span><br><span class="line">			seed++;		//seed为随机数种子</span><br><span class="line">			TIM_ClearITPendingBit(TIM3, TIM_IT_Update  ); </span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="随机生成苹果"><a href="#随机生成苹果" class="headerlink" title="随机生成苹果"></a>随机生成苹果</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Snake_apple (u32 seed)</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	srand ( seed );</span><br><span class="line">	apple_x = rand() % 46 + 1;</span><br><span class="line">	apple_y = rand() % 30 + 1;</span><br><span class="line">	Snake_drawpoint ( apple_x, apple_y, 1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="五、吃苹果-amp-加分"><a href="#五、吃苹果-amp-加分" class="headerlink" title="五、吃苹果&amp;加分"></a>五、吃苹果&amp;加分</h5><p>判断蛇头（身体）坐标是否与苹果坐标相同。如果相同，且蛇长不超过最大值，则分数加一，蛇长加一。</p>
<h6 id="代码：-2"><a href="#代码：-2" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">void Snake_eatapple ( u32 seed )</span><br><span class="line">&#123;</span><br><span class="line">	u16 i;</span><br><span class="line">	<span class="keyword">for</span> ( i = 0; i &lt; snake_long; i++ )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (snake[i][0] == apple_x &amp;&amp; snake[i][1] == apple_y)</span><br><span class="line">		&#123;</span><br><span class="line">			score++;</span><br><span class="line">			<span class="keyword">if</span> (snake_long &lt; 500)</span><br><span class="line">			&#123;</span><br><span class="line">				snake_long = snake_long+1;</span><br><span class="line">				snake[snake_long-1][0] = snake[snake_long-2][0];</span><br><span class="line">				snake[snake_long-1][1] = snake[snake_long-2][1];</span><br><span class="line">			&#125;</span><br><span class="line">			OLED_ShowNum ( 96, 24, score, 4, 12);</span><br><span class="line">			Snake_apple (seed);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="六、蛇伸长"><a href="#六、蛇伸长" class="headerlink" title="六、蛇伸长"></a>六、蛇伸长</h5><p>在上面吃苹果的部分中，我将增加新蛇头的数据储存为旧蛇头的数据，（如图），此时的蛇被“折叠”起来，随着蛇不断前进，到一定步数后才会真正在屏幕上伸长。<br><img src="https://s1.ax1x.com/2020/09/19/w5r5ss.jpg" alt="蛇伸长原理"></p>
<h5 id="七、撞墙-amp-撞蛇身"><a href="#七、撞墙-amp-撞蛇身" class="headerlink" title="七、撞墙&amp;撞蛇身"></a>七、撞墙&amp;撞蛇身</h5><p>判断蛇头的坐标是否与墙坐标和蛇身坐标相同。相同则结束游戏，显示“GAMEOVER”，几秒后将所有数据初始化，游戏自动重新开始。<br><img src="https://s1.ax1x.com/2020/09/19/wIfFXT.jpg" alt="游戏结束"></p>
<h5 id="八、调速"><a href="#八、调速" class="headerlink" title="八、调速"></a>八、调速</h5><p>使用外部中断服务，读取按键情况。每按一下变化蛇的速度，显示在屏幕上。我将速度设为四挡从1-4为从慢到快。</p>
<h6 id="代码：-3"><a href="#代码：-3" class="headerlink" title="代码："></a>代码：</h6><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u32 speed = 320;</span><br><span class="line">void EXTI2_IRQHandler ( void )</span><br><span class="line">&#123;</span><br><span class="line">	delay_ms( 10 );</span><br><span class="line">	<span class="keyword">if</span> ( KEY1 == 0 )</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ( speed &gt; 20 )</span><br><span class="line">			speed -= 100;</span><br><span class="line">		<span class="keyword">else</span> speed = 320;</span><br><span class="line">		OLED_ShowNum ( 96, 48, 4 - speed / 100, 4, 12);</span><br><span class="line">	&#125;		 </span><br><span class="line">	EXTI_ClearITPendingBit ( EXTI_Line2 ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="一些问题与想法"><a href="#一些问题与想法" class="headerlink" title="一些问题与想法"></a>一些问题与想法</h4><ul>
<li>没有设置控制游戏开始结束的按键。</li>
<li>使用摇杆时，由于摇杆过于灵活，有时候控制不好会出现蛇走的方向不受控制。</li>
<li>生成苹果时没有考虑消除苹果生成在蛇内部。为了减少麻烦，我是直接将判断苹果是不是在蛇内部，直接计分。</li>
<li>此时出现了一个问题，我一开始时是将吃苹果后苹果的坐标作为新蛇头，但如果苹果出现在蛇内部，就会出现蛇（<del>莫名其妙</del>）撞到自己（蛇头坐标等于蛇身坐标）。所以讲新蛇头设置为与旧蛇头一样的坐标。（与正常情况苹果生成在蛇外部是一样的）</li>
<li>优化：设置按键控制游戏开始结束、用按键控制蛇方向。</li>
<li>尝试：使用链表储存蛇数据、设置迷宫型地图。</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title>eplan_harness_prod_学习笔记</title>
    <url>/2021/01/26/eplan-harness-prod-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>本人在学校车队项目负责线束部分，由于网络上较难找到相关资料，因此将学习笔记记录于此。</p>
</blockquote>
<a id="more"></a>

<hr>
<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>EPLAN Harness prod是一款用于线束建模的软件。软件本身不复杂，但由于并不是广泛使用的软件，网络上学习的资源不多，学习阶段需要花点心思去研究，为新车进行线束建模的时候才会更加得心应手。</p>
<hr>
<h4 id="学习资源："><a href="#学习资源：" class="headerlink" title="学习资源："></a>学习资源：</h4><h6 id="网上资源：跟我一起学EPLAN-Harness-prod"><a href="#网上资源：跟我一起学EPLAN-Harness-prod" class="headerlink" title="网上资源：跟我一起学EPLAN Harness prod"></a><strong>网上资源：跟我一起学EPLAN Harness prod</strong></h6><p>点击链接进入话题 <a href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&__biz=MzA3MjAzNTQ3OA==&scene=1&album_id=1446650997702623233&count=3&uin=&key=&devicetype=Windows+10+x64&version=63010043&lang=zh_CN&ascene=1&fontgear=2">#EPLAN教程</a> 查找 “<strong>跟我一起学EPLAN Harness prod</strong>”共七篇文章。文章内容没有完全的介绍软件的各部分功能，主要用于<strong>学习软件的基本操作</strong>以及<strong>初步了解建模步骤</strong>。</p>
<h6 id="书本：《EPLAN-Harness-prod-官方教程》"><a href="#书本：《EPLAN-Harness-prod-官方教程》" class="headerlink" title="书本：《EPLAN Harness prod 官方教程》"></a><strong>书本：《EPLAN Harness prod 官方教程》</strong></h6><p>对软件的介绍比较齐全，能够查找到软件上各个操作的使用方法。<strong>建模时候遇到问题可翻查此书寻找解决方法</strong>。<br><img src="https://img2.doubanio.com/view/subject/l/public/s33778793.jpg" alt="《EPLAN Harness prod 官方教程》"></p>
<hr>
<h4 id="学习过程："><a href="#学习过程：" class="headerlink" title="学习过程："></a>学习过程：</h4><h6 id="1、初步了解软"><a href="#1、初步了解软" class="headerlink" title="1、初步了解软"></a><strong>1、初步了解软</strong></h6><p>从软件自带的样本模型入手，结合教程（软件和教程的模型会不一样），初步了解建模的基本步骤以及基本操作，并尝试建模。</p>
<h6 id="2、尝试对上赛季模型进行线束建模并构思本赛季线束模型"><a href="#2、尝试对上赛季模型进行线束建模并构思本赛季线束模型" class="headerlink" title="2、尝试对上赛季模型进行线束建模并构思本赛季线束模型"></a><strong>2、尝试对上赛季模型进行线束建模并构思本赛季线束模型</strong></h6><p><strong>阅读赛规</strong>，看懂<strong>整车线束原理图</strong>（<u>重点：安全回路，结合赛规看</u>），<strong>研究上赛季线束模型</strong>，了解并整理<strong>各用电器接口及其位置</strong>。并根据本赛季模型的变化，查找相关线束建模资料（网络，其他优秀车队等），研究并思考如何优化布线。</p>
<hr>
<h4 id="基于对方程式赛车线束布置的一些注意点："><a href="#基于对方程式赛车线束布置的一些注意点：" class="headerlink" title="基于对方程式赛车线束布置的一些注意点："></a>基于对方程式赛车线束布置的一些注意点：</h4><p>1、    电源线要根据走的电流大小用线。（搜UL1007 线径和载流量对应表）<br>2、    信号线用20AWG。<br>3、    颜色上，<strong>供电线必须是红黑色，安全回路必须是黄色，高压线是橙色</strong>，其他颜色随便用。<br>4、    <strong>黄色和橙色是不能乱用的颜色。</strong><br>5、    CAN线的GND一定要在终端接地。<br>6、    CAN线尽量不要绕到大电池和电机控制器那边，会有很强的电磁干扰。<br>7、    主开关面板和主控接插件位置会汇聚很多线，也会有很多需要分线的地方，布置的时候就把分线的位置分布得均匀一点，以防出现线堆积过多。<br>8、    接插件分布要合理，如果一个地方有很多接插件，也会变成一大坨。<br>9、    关于导入模型。建议整车各部分模型分开导入，直接把整车模型导入模型会丢失。<br>10、    关于导入导线。对导线、管脚、连接物等命名尽量使用英文进行命名。导入导线时使用中文命名会出现乱码的现象。<br>11、    布线时不建议自动生成导线。手动布线会更加了解整体的走线情况。</p>
<blockquote>
<p>（学习阶段，若有补充，后续更新）</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>FSA</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>初次见面</title>
    <url>/2020/09/17/%E5%88%9D%E6%AC%A1%E8%A7%81%E9%9D%A2/</url>
    <content><![CDATA[<p>你好！这里是阿欢同学的博客。<br>这里将分享我的学习笔记和一些生活趣事。<br>请多多指教！</p>
]]></content>
      <categories>
        <category>杂言</category>
      </categories>
      <tags>
        <tag>琐碎的事</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建笔记</title>
    <url>/2021/01/27/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>为了方便自己以后配置博客 : )</p>
<a id="more"></a>

<hr>
<h4 id="教程视频来源"><a href="#教程视频来源" class="headerlink" title="教程视频来源"></a><a href="https://www.bilibili.com/video/BV1nh411o738?p=1">教程视频来源</a></h4><hr>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p><a href="https://nodejs.org/en/">Nodejs</a><br><a href="https://gitforwindows.org/">Git Bash</a><br>打开 <strong>Git Bash</strong> 输入 <strong>node -v</strong> 和 <strong>npm -v</strong> 检验是否安装成功。</p>
<h4 id="启动CMD，输入以下指令"><a href="#启动CMD，输入以下指令" class="headerlink" title="启动CMD，输入以下指令"></a>启动CMD，输入以下指令</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> prefix “C:\博客搭建\Global”</span><br><span class="line">npm config <span class="built_in">set</span> cacha “C:\博客搭建\Global”</span><br></pre></td></tr></table></figure>
<p><strong>记住路径，配置变量的时候会用到</strong></p>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>打开 <strong>Git Bash</strong> 输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo</span><br></pre></td></tr></table></figure>
<p>如果Hexo无法使用，需要配置环境变量</p>
<h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>右击“此电脑”——“属性”——“高级系统设置”——“环境变量”——pc的用户变量——选中path——“编辑”——“新建”——输入“C:\博客搭建\Global”——“确定”<br><img src="https://s3.ax1x.com/2021/01/27/sxSLGR.png" alt="配置路径图一"><br><img src="https://s3.ax1x.com/2021/01/27/sxpkRI.png" alt="配置路径图二"></p>
<p>在<strong>Git Bash</strong> 输入 <strong>hexo -v</strong> 验证</p>
<hr>
<h2 id="配置博客"><a href="#配置博客" class="headerlink" title="配置博客"></a>配置博客</h2><h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><p>“C:\博客搭建”创建文件夹，命名为“Blog”<br>进入“Blog”——搜索栏输入cmd<br>进入cmd<br>输入 hexo init<br>输入 hexo s<br><img src="https://s3.ax1x.com/2021/01/27/sxp2wD.png" alt="初始化博客"><br>浏览器输入地址：<u><a href="http://localhost:4000/">http://localhost:4000</a></u><br>初始化博客成功</p>
<h4 id="配置博客-1"><a href="#配置博客-1" class="headerlink" title="配置博客"></a>配置博客</h4><p>打开Blog文件夹——用 Sublime Text 打开“_config.yml”<br><img src="https://s3.ax1x.com/2021/01/27/sxCcIe.png" alt="配置博客1"></p>
<p>修改信息 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">title:                                    <span class="comment">#博客名字</span></span><br><span class="line">subtitle: <span class="string">&#x27;good things take time :)&#x27;</span>      <span class="comment">#博客副标题</span></span><br><span class="line">description: <span class="string">&#x27;&#x27;</span>                           <span class="comment">#关于博客的描述</span></span><br><span class="line">keywords:</span><br><span class="line">author: Ren                               <span class="comment">#博客作者</span></span><br><span class="line">language: zh_CN                           <span class="comment">#博客语言</span></span><br><span class="line">timezone: <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure>

<h6 id="Hexo基本命令"><a href="#Hexo基本命令" class="headerlink" title="Hexo基本命令"></a>Hexo基本命令</h6><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">Hexo init</td>
<td align="center">初始化博客</td>
</tr>
<tr>
<td align="center">Hexo s</td>
<td align="center">运行博客</td>
</tr>
<tr>
<td align="center">Hexo n title</td>
<td align="center">创建一篇新的文章，文章标题是title</td>
</tr>
<tr>
<td align="center">Hexo c</td>
<td align="center">清理文件</td>
</tr>
<tr>
<td align="center">Hexo g</td>
<td align="center">生成静态文件</td>
</tr>
<tr>
<td align="center">Hexo d</td>
<td align="center">部署博客（需要插件）</td>
</tr>
</tbody></table>
<h4 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h4><p>CMD输入 <strong>Hexo n title</strong> 创建一篇新的文章，文章标题是title<br><img src="https://s3.ax1x.com/2021/01/27/sxP9dU.png" alt="写文章"><br>打开文件进行编辑<br>文章的编辑方式使用<a href="https://www.runoob.com/markdown/md-block.html"><strong>markdown</strong></a><br>文章保存后在 <strong>cmd</strong> 输入 <strong>hexo s</strong><br>打开连接可以看到新文章</p>
<h4 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h4><p><a href="https://hexo.io/themes/">themes|hexo</a><br>一般会有安装教程文章，详细阅读<br>在Blog文件——“_config.yml”里，找到theme，修改为已下载的主题的名字<br><img src="https://s3.ax1x.com/2021/01/27/sxPGQI.png" alt="配置主题"></p>
<p><strong>此处需要安装插件使博客能够运行。</strong><br>Cmd运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus</span><br></pre></td></tr></table></figure>
<p>安装插件。</p>
<blockquote>
<p>为方便以后升级方便，不建议对主题文件进行修改。推荐把主题的配置文件“_config.yml”复制到hexo工作目录下的source/_data/ayer.yml，如果目录不存在就创建一个。</p>
</blockquote>
<h4 id="更换图片"><a href="#更换图片" class="headerlink" title="更换图片"></a>更换图片</h4><p>使用网站 <strong><a href="https://imgchr.com/">路过图床</a></strong> 上传图片<br>使用图片UPL链接<br><img src="https://s3.ax1x.com/2021/01/27/sxFaGQ.png" alt="路过图床"> </p>
<h4 id="创建分类页、标签页、友链页"><a href="#创建分类页、标签页、友链页" class="headerlink" title="创建分类页、标签页、友链页"></a>创建分类页、标签页、友链页</h4><p>e.g.<br>分类页<br>前往hexo根目录<br>输入 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure>
<p>修改文件为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Title: 我的分类页</span><br><span class="line">Data: *******</span><br><span class="line">Type: <span class="string">&quot;catergories&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="友链添加"><a href="#友链添加" class="headerlink" title="友链添加"></a>友链添加</h4><p>在hexo博客目录中的source/_data，创建文件link.ylm<br>编辑</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Class_name:</span><br><span class="line">Class_desc:</span><br><span class="line">Link_list:</span><br><span class="line">	Name:				<span class="comment">#名字</span></span><br><span class="line">	Link:				<span class="comment">#网址</span></span><br><span class="line">	Avatar:				<span class="comment">#头像</span></span><br><span class="line">	Descry:				<span class="comment">#描述</span></span><br></pre></td></tr></table></figure>

<h4 id="关于文章置顶"><a href="#关于文章置顶" class="headerlink" title="关于文章置顶"></a>关于文章置顶</h4><p><strong>安装插件</strong><br>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top –-save</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="部署云端"><a href="#部署云端" class="headerlink" title="部署云端"></a>部署云端</h2><p>执行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>
<p>使用<strong>github</strong>部署云端<br>在GitHub中建立一个仓库，仓库名字必须是 <strong>xxx.github.io</strong> , xxx是GitHub名字<br>然后打开博客配置文件_config.yml<br>找到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Deploy:</span><br><span class="line">	Type: git</span><br><span class="line">	Repo:&lt;仓库地址&gt;</span><br><span class="line">	Branch: master </span><br></pre></td></tr></table></figure>
<p>cmd运行命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hexo clean </span><br><span class="line">hexo g</span><br><span class="line">Hexo d</span><br></pre></td></tr></table></figure>
<p>如果报错<br>根据提示运行命令</p>
<blockquote>
<p>创建博客完成</p>
</blockquote>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
</search>
